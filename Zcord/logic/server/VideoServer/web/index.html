<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>WebRTC P2P Chat</title>
  <style>
    body { background: #111; color: #eee; text-align: center; font-family: sans-serif; }
    video { width: 45%; margin: 10px; border-radius: 10px; background: #222; }
    button { margin: 10px; padding: 10px 20px; font-size: 16px; }
  </style>
</head>
<body>
  <h2>WebRTC P2P</h2>
  <div id="videos" style="display: flex; flex-wrap: wrap; justify-content: center;">
        <video id="localVideo" autoplay playsinline muted></video>
  </div>
  <button id="shareScreen">Поделиться экраном</button>
  <button id="unshareScreen">Перестать делится экраном</button>
  <script>
    const peers = {};   // peerId -> RTCPeerConnection
    const videos = {};  // peerId -> HTMLVideoElement
    const localVideo = document.getElementById("localVideo");

    let ws = null;
    let currentRoom = null;
    let localStream = null;

    function connect(room = null) {
      let url;
      if (room) {
          url = `ws://localhost:8080/ws?room=${room}`;
      }
      else {
          url = `ws://localhost:8080/ws`;
      }

      console.log("WS connect:", url);
      ws = new WebSocket(url);

      ws.onmessage = onWsMessage;
    }

    async function createPeerConnection(peerId) {
      const pc = new RTCPeerConnection({
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
      });

      peers[peerId] = pc;

      // локальные треки
      if (!localStream) {
          localStream = createBlackStream();
          localVideo.srcObject = null;
      }

      localStream.getTracks().forEach(track =>
        pc.addTrack(track, localStream)
       );

      pc.ontrack = (event) => {
        const video = videos[peerId] || createRemoteVideo(peerId);
        video.srcObject = event.streams[0];
      };

      pc.onicecandidate = (event) => {
        if (event.candidate) {
          ws.send(JSON.stringify({
            type: "candidate",
            target: peerId,
            candidate: event.candidate
          }));
        }
      };

      return pc;
    }

    function replaceVideoTrack(track) {
      Object.values(peers).forEach(pc => {
        const sender = pc.getSenders().find(s => s.track?.kind === "video");
        if (sender) sender.replaceTrack(track);
      });
    }

    function createBlackStream() {
      const canvas = document.createElement("canvas");
      canvas.width = 640;
      canvas.height = 320;
      const ctx = canvas.getContext("2d");
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      return canvas.captureStream(1);  // 1 FPS для производительности
    }

    function createRemoteVideo(peerId) {
      const video = document.createElement("video");
      video.autoplay = true;
      video.playsInline = true;
      video.style.width = "45%";
      video.style.margin = "10px";
      video.id = `video-${peerId}`;

      document.getElementById("videos").appendChild(video);
      videos[peerId] = video;
      return video;
    }

    function removePeer(peerId) {
      console.log("Удаляем пира:", peerId);

      if (peers[peerId]) {
        peers[peerId].close();
        delete peers[peerId];
      }

      if (videos[peerId]) {
        videos[peerId].remove();
        delete videos[peerId];
      }
    }

    document.getElementById("unshareScreen").addEventListener("click", async () => {
        try {
            const blackStream = createBlackStream();
            localStream = blackStream;
            localVideo.srcObject = null;
            replaceVideoTrack(blackStream.getVideoTracks()[0]);
        } catch (err) {
            console.error("Ошибка при получении black_stream:", err);
        }
    });

    document.getElementById("shareScreen").addEventListener("click", async () => {
      try {
        const screenStream = await navigator.mediaDevices.getDisplayMedia({
          video: { cursor: "always" },
          audio: true
        });

        localStream = screenStream;
        localVideo.srcObject = screenStream;

        replaceVideoTrack(screenStream.getVideoTracks()[0]);

        screenStream.getVideoTracks()[0].onended = async () => {
          const blackStream = createBlackStream();
          localStream = blackStream;
          localVideo.srcObject = null;
          replaceVideoTrack(blackStream.getVideoTracks()[0]);
        };
      } catch (err) {
        console.error("Ошибка при получении экрана:", err);
      }
    });

    async function onWsMessage(event) {
      const data = JSON.parse(event.data);
      console.log("WS <-", data.type, data);

      if (data.type === "assign-room") {
        if (currentRoom === data.room) return;

        console.log("Assigned room:", data.room);
        currentRoom = data.room;

        ws.close();
        connect(currentRoom);
        return;
      }

      // пока room не подтверждён — ничего не делаем
      if (!currentRoom) return;

      // новый пользователь
      if (data.type === "peer-joined") {
        const pc = await createPeerConnection(data.peerId);

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        console.log("SEND OFFER ->", data.peerId);
        ws.send(JSON.stringify({
          type: "offer",
          target: data.peerId,
          offer
        }));
      }

      // пришёл offer
      else if (data.type === "offer") {
        const pc = await createPeerConnection(data.from);
        await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
        console.log("SEND ANSWER ->", data.from);
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        ws.send(JSON.stringify({
          type: "answer",
          target: data.from,
          answer
        }));
      }

      // пришёл answer
      else if (data.type === "answer") {
        await peers[data.from].setRemoteDescription(
          new RTCSessionDescription(data.answer)
        );
      }

      // ICE
      else if (data.type === "candidate") {
        try {
            const pc = peers[data.from];

            if (pc.remoteDescription) {
              await pc.addIceCandidate(data.candidate);
            }
        } catch (e) {
          console.error("ICE error", e);
        }
      }

      // пользователь вышел
      else if (data.type === "peer-left") {
          console.log(data)
        removePeer(data.peerId);
      }

      else if (data.type === "tcp-message") {
        console.log("TCP → Browser:", data.payload);
      }
    }
  </script>
</body>
</html>
